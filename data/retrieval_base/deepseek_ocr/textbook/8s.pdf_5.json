[
  {
    "page_idx": 0,
    "text": "Answer:\n\na. α should be a primary key for \\( r_1 \\), and α should be the foreign key from \\( r_2 \\), referencing \\( r_1 \\).\n\nb. If the foreign key constraint is not enforced, then a deletion of a tuple from \\( r_1 \\) would not have a corresponding deletion from the referencing tuples in \\( r_2 \\). Instead of deleting a tuple from \\( r \\), this would amount to simply setting the value of α to null in some tuples.\n\nc. For every schema \\( r_i(\\alpha\\beta) \\) added to the schema because of a rule \\( \\alpha \\rightarrow \\beta \\), α should be made the primary key. Also, a candidate key \\( \\gamma \\) for the original relation is located in some newly created relation \\( r_k \\), and is a primary key for that relation. Foreign key constraints are created as follows: for each relation \\( r_i \\) created above, if the primary key attributes of \\( r_i \\) also occur in any other relation \\( r_j \\), then a foreign key constraint is created from those attributes in \\( r_j \\), referencing (the primary key of) \\( r_i \\).\n\n8.12 Let \\( R_1, R_2, \\ldots, R_n \\) be a decomposition of schema \\( U \\). Let \\( u(U) \\) be a relation, and let \\( r_i = \\Pi_{R_i}(u) \\). Show that\n\n\\[\nu \\subseteq r_1 \\bowtie r_2 \\bowtie \\cdots \\bowtie r_n\n\\]\n\nAnswer: Consider some tuple \\( t \\) in \\( u \\). Note that \\( r_i = \\Pi_{R_i}(u) \\) implies that \\( t[R_i] \\in r_i, 1 \\leq i \\leq n \\). Thus,\n\n\\[\nt[R_1] \\bowtie t[R_2] \\bowtie \\cdots \\bowtie t[R_n] \\in r_1 \\bowtie r_2 \\bowtie \\cdots \\bowties r_n\n\\]\n\nBy the definition of natural join,\n\n\\[\nt[R_1] \\bowtie t[R_2] \\bowti \\cdots \\bowtie t[R_n] = \\Pi_{\\alpha} (\\sigma_{\\beta} (t[R_1] \\bowtie t[R_2] \\bowti \\cdots t[R_n]))\n\\]\n\nwhere the condition \\( \\beta \\) is satisfied if values of attributes with the same name in a tuple are equal and where \\( \\alpha = U \\). The cartesian product of single tuples generates one tuple. The selection process is satisfied because all attributes with the same name must have the same value since they are projections from the same tuple. Finally, the projection clause removes duplicate attribute names. By the definition of decomposition, \\( U = R_1 \\cup R_2 \\cup \\cdots \\cup R_n \\), which means that all attributes of \\( t \\) are in \\( t[R_1] \\bowtie t[R_2] \\bowti \\cdots \\Bowtie t[R_n] \\). That is, \\( t \\) is equal to the result of this join. Since \\( t \\) is any arbitrary tuple in \\( u \\),\n\n\\[\nu \\subseteq r_1 \\bowtie r_2 \\bowtie r_n\n\\]\n\n8.13 Show that the decomposition in Practice Exercise 8.1 is not a dependency-preserving decomposition. Answer: The dependency \\( B \\rightarrow D \\) is not preserved. \\( F_1 \\), the restriction of \\( F \\) to \\( (A, B, C) \\) is \\( A \\rightarrow ABC, A \\rightarrow AB, A \\rightarrow AC, A \\rightarrow BC \\),"
  }
]